# Data Model: Todo Console App

**Feature**: Todo Console App
**Date**: 2025-12-29
**Status**: Complete

## Task Entity

The Task entity represents a single todo item in the application.

### Properties

| Property | Type | Constraints | Description |
|----------|------|-------------|-------------|
| id | int | Required, Unique, Auto-generated | Unique identifier for the task |
| title | str | Required, 1-200 characters | The task title/description |
| description | str | Optional, 0-1000 characters | Additional details about the task |
| completed | bool | Required, Default: False | Completion status of the task |
| created_at | datetime | Required, Auto-generated | Timestamp when task was created |
| updated_at | datetime | Required, Auto-generated/Updated | Timestamp when task was last modified |

### Class Definition

```python
from datetime import datetime
from typing import Optional

class Task:
    def __init__(self, id: int, title: str, description: Optional[str] = None, completed: bool = False):
        if not title or len(title) < 1 or len(title) > 200:
            raise ValueError("Title must be between 1 and 200 characters")
        if description and len(description) > 1000:
            raise ValueError("Description must be 1000 characters or less")
        
        self.id = id
        self.title = title
        self.description = description or ""
        self.completed = completed
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def to_dict(self) -> dict:
        """Convert task to dictionary representation"""
        return {
            "id": self.id,
            "title": self.title,
            "description": self.description,
            "completed": self.completed,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'Task':
        """Create task from dictionary representation"""
        task = cls(
            id=data["id"],
            title=data["title"],
            description=data.get("description"),
            completed=data.get("completed", False)
        )
        # Restore timestamps if present
        if "created_at" in data:
            task.created_at = datetime.fromisoformat(data["created_at"])
        if "updated_at" in data:
            task.updated_at = datetime.fromisoformat(data["updated_at"])
        return task
    
    def __str__(self) -> str:
        """String representation for display"""
        status = "✓" if self.completed else "○"
        return f"[{status}] {self.id}. {self.title}"
```

### Validation Rules

1. **Title**: Must be 1-200 characters, required field
2. **Description**: Optional, max 1000 characters if provided
3. **Completion Status**: Boolean, defaults to False
4. **ID**: Unique integer, auto-generated by storage layer
5. **Timestamps**: Auto-generated, updated when task is modified

### State Transitions

The Task entity has a single state transition related to its completion status:
- `incomplete` → `completed`: When user marks task as complete
- `completed` → `incomplete`: When user marks task as incomplete

## Storage Model

### In-Memory Storage Structure

```python
# Internal storage representation
tasks: dict[int, Task] = {}
next_id: int = 1
```

The storage layer uses a dictionary where:
- Keys are integer task IDs
- Values are Task objects
- An additional counter tracks the next available ID

### Migration Considerations for Phase II

The data model is designed with future database migration in mind:

1. **Field Mapping**: All fields will map directly to database columns
   - `id`: Primary key (auto-incrementing)
   - `title`: VARCHAR(200), NOT NULL
   - `description`: TEXT, NULLABLE
   - `completed`: BOOLEAN, NOT NULL, DEFAULT FALSE
   - `created_at`: TIMESTAMP, NOT NULL
   - `updated_at`: TIMESTAMP, NOT NULL

2. **Indexing**: Primary key index on `id` for O(1) lookups

3. **Constraints**: Database-level constraints will mirror validation rules